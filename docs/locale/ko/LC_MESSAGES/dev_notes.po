# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018, Mark Mc Mahon and Contributors
# This file is distributed under the same license as the pywinauto package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pywinauto 0.6.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-02-12 11:45+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../dev_notes.txt:3
msgid "Dev Notes"
msgstr ""

#: ../../dev_notes.txt:7
msgid "FILE LAYOUT"
msgstr ""

#: ../../dev_notes.txt:9
msgid ""
"# used by just about everything (and considered a block!) win32defines.py"
" win32functions.py win32structures.py"
msgstr ""

#: ../../dev_notes.txt:14
msgid "# Find windows and their attributes findwindows.py handleprops.py"
msgstr ""

#: ../../dev_notes.txt:18
msgid ""
"# wrap windows, get extra info for particular controls # set the friendly"
" class name controls\\common_controls.py controls\\controlactions.py "
"controls\\hwndwrapper.py controls\\win32_controls.py"
msgstr ""

#: ../../dev_notes.txt:25
msgid ""
"# currently depends on the Friendly class name # probably needs to be "
"refactored to make it independent of controls! # maybe move that stuff to"
" _application_? findbestmatch.py  # currently depends on controls!"
msgstr ""

#: ../../dev_notes.txt:31
msgid "controlactions.py"
msgstr ""

#: ../../dev_notes.txt:33
msgid ""
"tests\\allcontrols.py tests\\asianhotkey.py "
"tests\\comboboxdroppedheight.py tests\\comparetoreffont.py "
"tests\\leadtrailspaces.py tests\\miscvalues.py tests\\missalignment.py "
"tests\\missingextrastring.py tests\\overlapping.py "
"tests\\repeatedhotkey.py tests\\translation.py tests\\truncation.py"
msgstr ""

#: ../../dev_notes.txt:47
msgid "controlproperties.py"
msgstr ""

#: ../../dev_notes.txt:49
msgid "xml_helpers.py"
msgstr ""

#: ../../dev_notes.txt:51
msgid "FindDialog.py PyDlgCheckerWrapper.py"
msgstr ""

#: ../../dev_notes.txt:54
msgid "application.py test_application.py"
msgstr ""

#: ../../dev_notes.txt:60
msgid "Best matching"
msgstr ""

#: ../../dev_notes.txt:61
msgid ""
"difflib provides this support For menu's it is simple we match against "
"the text of the menu item. For controls the story is more complicated "
"because we want to match against the following:"
msgstr ""

#: ../../dev_notes.txt:66
msgid "Control text if it exists"
msgstr ""

#: ../../dev_notes.txt:67
msgid "Friendly Class name"
msgstr ""

#: ../../dev_notes.txt:68
msgid "Control text + Friendly class name (if control text exists)"
msgstr ""

#: ../../dev_notes.txt:69
msgid "(Possibly) closest static + FriendlyClassName"
msgstr ""

#: ../../dev_notes.txt:71
msgid "e.g."
msgstr ""

#: ../../dev_notes.txt:72
msgid "FindWhatCombo, ComboBox1,"
msgstr ""

#: ../../dev_notes.txt:74
msgid "or"
msgstr ""

#: ../../dev_notes.txt:74
msgid "Text, TextRiadio, RadioButton2"
msgstr ""

#: ../../dev_notes.txt:76
msgid "the control itself knows what it should be referred to"
msgstr ""

#: ../../dev_notes.txt:77
msgid "Need to disambiguate across all controls in the dialog"
msgstr ""

#: ../../dev_notes.txt:78
msgid "then we need to match"
msgstr ""

#: ../../dev_notes.txt:84
msgid "ATTRIBUTE RESOLUTION"
msgstr ""

#: ../../dev_notes.txt:85
msgid "Thinking again... app.dlg.control"
msgstr ""

#: ../../dev_notes.txt:95
msgid "TWO LEVELS"
msgstr ""

#: ../../dev_notes.txt:92
msgid "application.member (Python resolves)"
msgstr ""

#: ../../dev_notes.txt:93
msgid "an attribute of application object"
msgstr ""

#: ../../dev_notes.txt:95
msgid "application.dialog"
msgstr ""

#: ../../dev_notes.txt:95
msgid "a dialog reference"
msgstr ""

#: ../../dev_notes.txt:103
msgid "THREE LEVELS"
msgstr ""

#: ../../dev_notes.txt:98
msgid "application.member.attr (Python resolves)"
msgstr ""

#: ../../dev_notes.txt:99
msgid "another attribute of the previous member"
msgstr ""

#: ../../dev_notes.txt:100
msgid "application.dialog.member"
msgstr ""

#: ../../dev_notes.txt:101
msgid "a member of the dialog object"
msgstr ""

#: ../../dev_notes.txt:103
msgid "application.dialog.control"
msgstr ""

#: ../../dev_notes.txt:103
msgid "a control on the dialog"
msgstr ""

#: ../../dev_notes.txt:108
msgid "FOUR LEVELS (leaving out Python resolved)"
msgstr ""

#: ../../dev_notes.txt:106
msgid "application.dialog.member.member"
msgstr ""

#: ../../dev_notes.txt:107
msgid "application.dialog.control.member"
msgstr ""

#: ../../dev_notes.txt:110
msgid "DELAYED RESOLUTION FOR SUCCESS Taking the example ::"
msgstr ""

#: ../../dev_notes.txt:115
msgid ""
"If we leave out syntax and programming errors there are still a number of"
" reasons why it could fail."
msgstr ""

#: ../../dev_notes.txt:117
msgid ""
"dlg might not be found control might not be found either dlg or control "
"may be disabled"
msgstr ""

#: ../../dev_notes.txt:121
msgid ""
"dialog and control may be found but on the wrong dialog (e.g. in Notepad "
"you can bring up 2 \"Page Setup\" dialogs both with an OK button)"
msgstr ""

#: ../../dev_notes.txt:123
msgid ""
"One solution would just be to add a \"sleep\" before trying to find each "
"new dialog (to ensure that it is there and ready) - but this will mean "
"lots of unnecessary waiting."
msgstr ""

#: ../../dev_notes.txt:128
msgid "So the solution I have tried is:"
msgstr ""

#: ../../dev_notes.txt:126
msgid ""
"perform the complete attribute access resolution at the latest possible "
"time"
msgstr ""

#: ../../dev_notes.txt:127
msgid "if it fails then wait and try again"
msgstr ""

#: ../../dev_notes.txt:128
msgid "after a specified timeout fail raising the original exception."
msgstr ""

#: ../../dev_notes.txt:130
msgid ""
"This means that in the normal case you don't have unnecessary waits - and"
" in the failure case - you still get an exception with the error."
msgstr ""

#: ../../dev_notes.txt:132
msgid ""
"Also waiting to do resolution as late as possible stops errors where an "
"earlier part of the path succeedes - but finds the wrong item."
msgstr ""

#: ../../dev_notes.txt:134
msgid ""
"So for example if  finds the page setup dialog in Notepad # open the "
"Printer setup dialog (which has \"Page Setup\" as title) "
"app.PageSetup.Printer.Click()"
msgstr ""

#: ../../dev_notes.txt:138
msgid ""
"# if this runs too quickly it actually finds the current page setup "
"dialog # before the next dialog opens, but that dialog does not have a "
"Properties # button - so an error is raised. # because we re-run the "
"resolution from the start we find the new pagesetup dialog. "
"app.PageSetup.Properties.Click()"
msgstr ""

#: ../../dev_notes.txt:148
msgid "WRITING TO DIALOGS"
msgstr ""

#: ../../dev_notes.txt:149
msgid ""
"We need a way of making sure that the dialog is active without having to "
"access a control on it. e.g. ::"
msgstr ""

#: ../../dev_notes.txt:155
msgid "or a harder problem::"
msgstr ""

#: ../../dev_notes.txt:160
msgid ""
"In this second example it is very hard to be sure that the correct Page "
"Setup dialog is shown."
msgstr ""

#: ../../dev_notes.txt:162
msgid ""
"The only way to be realy sure is to check for the existance of certain "
"control(s) (ID, Class, text, whatever) - but it would be nice to not have"
" to deal with those :-("
msgstr ""

#: ../../dev_notes.txt:164
msgid ""
"Another less declarative (more magic?) is to scan the list of available "
"windows/controls and if they haven't changed then accept that the correct"
" one is shown."
msgstr ""

#: ../../dev_notes.txt:166
msgid ""
"When testing and having XML files then we should use those to make sure "
"that we have the correct dialog up (by using Class/ID)"
msgstr ""

